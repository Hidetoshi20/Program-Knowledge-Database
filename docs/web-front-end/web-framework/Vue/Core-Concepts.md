# Vue 核心概念

## data 为什么是函数？

在组件化的开发中，我们期望每个组件实例都是独立的，拥有自己的作用域和私有状态。

JavaScript 中，对象的属性是引用类型的。如果 `data` 是一个对象，那么所有组件实例将共享同一个 `data` 对象。当一个组件修改了 `data`，其他所有组件的 `data` 也会被修改，这会造成数据污染。

当 `data` 是一个函数时，每个组件实例在创建时都会调用这个函数，返回一个新的对象。这样，每个实例都维护了一份独立的数据拷贝，互不影响。

```javascript
// 错误示范：data 是一个对象
export default {
  data: {
    count: 0 // 所有实例共享这个 count
  }
}

// 正确示范：data 是一个函数
export default {
  data() {
    return {
      count: 0 // 每个实例都有自己的 count
    }
  }
}
```
> 注意：在 `new Vue()` 根实例中，`data` 可以是一个对象，因为根实例是唯一的。

## v-if vs v-show

两者都是用来显示和隐藏元素的指令。

| 指令 | `v-if` | `v-show` |
| --- | --- | --- |
| **原理** | 真实地销毁和重建 DOM 元素。 | 通过 CSS 的 `display: none` 来控制元素的显示和隐藏。 |
| **编译** | 如果初始条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染。 | 无论初始条件是什么，元素总是会被渲染，只是简单地基于 CSS 进行切换。 |
| **性能开销** | 有更高的切换开销（DOM 的创建和销毁）。 | 有更高的初始渲染开销。 |
| **适用场景** | 如果运行时条件很少改变，使用 `v-if` 较好。 | 如果需要非常频繁地切换，使用 `v-show` 较好。 |

`v-if` 是“惰性的”，并且有 `v-else` 和 `v-else-if` 作为补充。

## v-for 中 key 的作用

`key` 的主要作用是为了**高效地更新虚拟DOM**。

Vue 和 React 的 Diff 算法类似，它基于一些假设来优化性能，其中之一就是：它会尽可能地复用同一层级的已有 DOM 元素。

当 Vue 正在更新使用 `v-for` 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。

这种默认模式是高效的，但是**只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出**。

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的 `key` attribute。

-   **不使用 `key`**: 在列表的开头或中间插入元素时，Vue 会复用并更新现有的 DOM，而不是移动它们。这可能导致性能问题和状态混乱。
-   **使用 `index` 作为 `key`**: 当列表顺序改变时，`index` 也会改变，这和不使用 `key` 的问题类似。如果只是渲染静态内容，可以使用 `index`，但如果涉及到组件状态、表单输入或动画，则不推荐。
-   **使用唯一 ID 作为 `key`**: 这是最佳实践。`key` 应该是稳定、唯一且可预测的。这样 Diff 算法就可以正确地识别节点，高效地进行移动、创建或删除操作。

## $nextTick

**作用**: 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

**原理**: Vue 在更新 DOM 时是**异步**执行的。当数据发生变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。在缓冲时会去除重复数据，从而避免不必要的计算和 DOM 操作。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。

`$nextTick` 就是为了让我们在 DOM 更新之后执行操作。它主要使用了宏任务和微任务的机制，根据执行环境分别尝试采用：

1.  `Promise` (微任务)
2.  `MutationObserver` (微任务)
3.  `setImmediate` (宏任务, 仅 IE)
4.  `setTimeout` (宏任务)

## delete vs Vue.delete

-   `delete`: 这是 JavaScript 的原生操作符。当用它删除数组中的一个元素时，它只会将该元素的值变为 `empty`，但**不会改变数组的长度**，并且这个操作**不是响应式**的。
-   `Vue.delete` (或 `this.$delete`): 这是 Vue 的实例方法。它会从目标对象或数组中删除属性/元素，并**确保这个删除操作是响应式的**，能够触发视图更新。它实际上是 `Vue.set` 的一个别名。

```javascript
let arr1 = [1, 2, 3]
let arr2 = [1, 2, 3]

delete arr1[1]
this.$delete(arr2, 1) // 注意，第二个参数是索引

console.log(arr1)    // [1, empty, 3]
console.log(arr2)    // [1, 3]
```

## refs / $parent / $children

-   `$refs`: 在子组件或 HTML 元素上使用 `ref` attribute 后，`this.$refs` 会持有对这些子组件实例或 DOM 元素的引用。这是访问子组件或 DOM 的直接方式。
-   `$parent`: 访问父组件的实例。
-   `$children`: 访问当前实例的直接子组件数组。

**注意**: `$parent` 和 `$children` 应该被视为最后的退路。它们会使组件之间产生强耦合，让代码更难理解和调试。在大多数情况下，应该优先使用 `props` 和 `$emit`。`$refs` 也应该避免在模板或计算属性中访问。
